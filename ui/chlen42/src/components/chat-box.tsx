"use client";

/**
 * This code was generated by v0 by Vercel.
 * @see https://v0.dev/t/5o8Wwynb6Lg
 */
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import ChatBubble from "./chat-bubble";
import { useCallback, useEffect, useRef, useState } from "react";
import { ScrollArea } from "./ui/scroll-area";
import useStore, { selector } from "./store";
import { shallow } from "zustand/shallow";

type Message = {
  content: string;
  fromBot: boolean;
};

export function ChatBox() {
  const [typedMessage, setTypedMessage] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isFetching, setIsFetching] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const { updateNodeType } = useStore(selector, shallow);

  useEffect(() => {
    setTimeout(() => messagesEndRef.current?.scrollIntoView({ behavior: "smooth" }), 100);
  }, [messages]);

  const fetchBot = async (query: string) => {
    const res = await fetch("http://localhost:4000/chat", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ query }),
    });
    const data: {
      response: string;
      related_files: string[];
    } = await res.json();

    return data;
  };

  const send = useCallback(() => {
    if (typedMessage === "") return;

    setMessages((prev) => [...prev, { content: typedMessage, fromBot: false }]);
    // clear input
    setTypedMessage("");
    if (inputRef.current) {
      inputRef.current.value = "";
    }
    setIsFetching(true);
    fetchBot(typedMessage)
      .then(async (data) => {
        const articleNodeIds = data.related_files.map((s) => s.match(/^dataset\/([a-я0-9]+)\.txt$/)?.[1] ?? "");

        updateNodeType(articleNodeIds, "article-node");
        setIsFetching(false);
        setMessages((prev) => [...prev, { content: data.response, fromBot: true }]);
      })
      .catch(async (e) => {
        console.error(e);
        await new Promise((r) => setTimeout(r, 5000));
        setIsFetching(false);
        setMessages((prev) => [...prev, { content: "Error", fromBot: true }]);
      });
  }, [typedMessage, updateNodeType]);

  useEffect(() => {
    const sendMsg = (e: KeyboardEvent) => {
      if (e.key === "Enter") {
        send();
      }
    };

    addEventListener("keydown", sendMsg);

    return () => {
      removeEventListener("keydown", sendMsg);
    };
  });

  return (
    <div className="w-100 h-full flex flex-col gap-2" style={{ direction: "ltr" }}>
      <ScrollArea className="h-full">
        <div className="flex flex-col gap-2 pr-3">
          {messages.map((msg, i) => (
            <ChatBubble key={i} name={msg.fromBot ? "Bot" : "You"} message={msg.content} other={msg.fromBot} />
          ))}
          {isFetching && (
            <ChatBubble
              name="Bot"
              message={
                <div className="flex gap-2 mt-2">
                  <div className="animate-bounce bg-gray-200 h-2 w-2 rounded-full delay-100" />
                  <div className="animate-bounce bg-gray-200 h-2 w-2 rounded-full delay-200" />
                  <div className="animate-bounce bg-gray-200 h-2 w-2 rounded-full delay-300" />
                </div>
              }
              other={true}
            />
          )}
          <div ref={messagesEndRef} />
        </div>
      </ScrollArea>
      <div className="flex gap-2">
        <Input
          ref={inputRef}
          className="text-black"
          onChange={(el) => {
            setTypedMessage(el.target.value);
          }}
        />
        <Button onClick={send}>Ask</Button>
      </div>
    </div>
  );
}
